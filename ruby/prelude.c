/* -*-c-*-
 THIS FILE WAS AUTOGENERATED BY tool/compile_prelude.rb. DO NOT EDIT.

 soruces: ./prelude.rb, ./enc/prelude.rb, ./gem_prelude.rb
*/
#include "ruby/ruby.h"
#include "vm_core.h"

static const char prelude_name0[] = "<internal:prelude>";
static const char prelude_code0[] =
"\n"
"# Mutex\n"
"\n"
"class Mutex\n"
"  def synchronize\n"
"    self.lock\n"
"    begin\n"
"      yield\n"
"    ensure\n"
"      self.unlock rescue nil\n"
"    end\n"
"  end\n"
"end\n"
"\n"
"# Thread\n"
"\n"
"class Thread\n"
"  MUTEX_FOR_THREAD_EXCLUSIVE = Mutex.new\n"
"  def self.exclusive\n"
"    MUTEX_FOR_THREAD_EXCLUSIVE.synchronize{\n"
"      yield\n"
"    }\n"
"  end\n"
"end\n"
"\n"
"def require_relative(relative_feature)\n"
"  c = caller.first\n"
"  e = c.rindex(/:\\d+:in /)\n"
"  file = $`\n"
"  if /\\A\\((.*)\\)/ =~ file # eval, etc.\n"
"    raise LoadError, \"require_relative is called in #{$1}\"\n"
"  end\n"
"  absolute_feature = File.expand_path(File.join(File.dirname(file), relative_feature))\n"
"  require absolute_feature\n"
"end\n"
;
static const char prelude_name1[] = "<internal:prelude>";
static const char prelude_code1[] =
"%w'enc/encdb.so enc/trans/transdb.so'.each do |init|\n"
"  begin\n"
"    require(init)\n"
"  rescue LoadError\n"
"  end\n"
"end\n"
;
static const char prelude_name2[] = "<internal:gem_prelude>";
static const char prelude_code2[] =
"TMP_RUBY_PREFIX = $:.reverse.find{|e|e!=\".\"}.sub(%r{(.*)/lib/.*}m, \"\\\\1\")\n"
"# depends on: array.rb dir.rb env.rb file.rb hash.rb module.rb regexp.rb\n"
"# vim: filetype=ruby\n"
"\n"
"# NOTICE: Ruby is during initialization here.\n"
"# * Encoding.default_external does not reflects -E.\n"
"# * Should not expect Encoding.default_internal.\n"
"# * Locale encoding is available.\n"
"\n"
"if defined?(Gem) then\n"
"\n"
"  # :stopdoc:\n"
"\n"
"  module Kernel\n"
"\n"
"    def gem(gem_name, *version_requirements)\n"
"      Gem.push_gem_version_on_load_path(gem_name, *version_requirements)\n"
"    end\n"
"\n"
"  end\n"
"\n"
"  module Gem\n"
"\n"
"    ConfigMap = {\n"
"      :EXEEXT            => \"\",\n"
"      :RUBY_SO_NAME      => \"ruby\",\n"
"      :arch              => \"i386-darwin9.8.0\",\n"
"      :bindir            => \"#{TMP_RUBY_PREFIX}/bin\",\n"
"      :libdir            => \"#{TMP_RUBY_PREFIX}/lib\",\n"
"      :ruby_install_name => \"ruby\",\n"
"      :ruby_version      => \"1.9.1\",\n"
"      :rubylibprefix     => \"#{TMP_RUBY_PREFIX}/lib/ruby\",\n"
"      :sitedir           => \"#{TMP_RUBY_PREFIX}/lib/ruby/site_ruby\",\n"
"      :sitelibdir        => \"#{TMP_RUBY_PREFIX}/lib/ruby/site_ruby/1.9.1\",\n"
"    }\n"
"\n"
"    def self.dir\n"
"      @gem_home ||= nil\n"
"      set_home(ENV['GEM_HOME'] || default_dir) unless @gem_home\n"
"      @gem_home\n"
"    end\n"
"\n"
"    def self.path\n"
"      @gem_path ||= nil\n"
"      unless @gem_path\n"
"        paths = [ENV['GEM_PATH'] || default_path]\n"
"        paths << APPLE_GEM_HOME if defined? APPLE_GEM_HOME\n"
"        set_paths(paths.compact.join(File::PATH_SEPARATOR))\n"
"      end\n"
"      @gem_path\n"
"    end\n"
"\n"
"    def self.post_install(&hook)\n"
"      @post_install_hooks << hook\n"
"    end\n"
"\n"
"    def self.post_uninstall(&hook)\n"
"      @post_uninstall_hooks << hook\n"
"    end\n"
"\n"
"    def self.pre_install(&hook)\n"
"      @pre_install_hooks << hook\n"
"    end\n"
"\n"
"    def self.pre_uninstall(&hook)\n"
"      @pre_uninstall_hooks << hook\n"
"    end\n"
"\n"
"    def self.set_home(home)\n"
"      home = home.gsub File::ALT_SEPARATOR, File::SEPARATOR if File::ALT_SEPARATOR\n"
"      @gem_home = home\n"
"    end\n"
"\n"
"    def self.set_paths(gpaths)\n"
"      if gpaths\n"
"        @gem_path = gpaths.split(File::PATH_SEPARATOR)\n"
"\n"
"        if File::ALT_SEPARATOR then\n"
"          @gem_path.map! do |path|\n"
"            path.gsub File::ALT_SEPARATOR, File::SEPARATOR\n"
"          end\n"
"        end\n"
"\n"
"        @gem_path << Gem.dir\n"
"      else\n"
"        # TODO: should this be Gem.default_path instead?\n"
"        @gem_path = [Gem.dir]\n"
"      end\n"
"\n"
"      @gem_path.uniq!\n"
"    end\n"
"\n"
"    def self.user_home\n"
"      @user_home ||= File.expand_path(\"~\")\n"
"    rescue\n"
"      if File::ALT_SEPARATOR then\n"
"        \"C:/\"\n"
"      else\n"
"        \"/\"\n"
"      end\n"
"    end\n"
"\n"
"    # begin rubygems/defaults\n"
"    # NOTE: this require will be replaced with in-place eval before compilation.\n"
"eval("
"\"module Gem\\n\""
"\"\\n\""
"\"  @post_install_hooks   ||= []\\n\""
"\"  @post_uninstall_hooks ||= []\\n\""
"\"  @pre_uninstall_hooks  ||= []\\n\""
"\"  @pre_install_hooks    ||= []\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # An Array of the default sources that come with RubyGems\\n\""
"\"\\n\""
"\"  def self.default_sources\\n\""
"\"    %w[http://gems.rubyforge.org/]\\n\""
"\"  end\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # Default home directory path to be used if an alternate value is not\\n\""
"\"  # specified in the environment\\n\""
"\"\\n\""
"\"  def self.default_dir\\n\""
"\"    if defined? RUBY_FRAMEWORK_VERSION then\\n\""
"\"      File.join File.dirname(ConfigMap[:sitedir]), 'Gems',\\n\""
"\"                ConfigMap[:ruby_version]\\n\""
"\"    elsif RUBY_VERSION >= '1.9.2' then\\n\""
"\"      File.join(ConfigMap[:rubylibprefix], 'gems',\\n\""
"\"                ConfigMap[:ruby_version])\\n\""
"\"    # only Ruby 1.9.1 has a peculiar feature\\n\""
"\"    elsif RUBY_VERSION > '1.9' and \\n\""
"\"      File.join(ConfigMap[:libdir], ConfigMap[:ruby_install_name], 'gems',\\n\""
"\"                ConfigMap[:ruby_version])\\n\""
"\"    else\\n\""
"\"      File.join(ConfigMap[:libdir], ruby_engine, 'gems',\\n\""
"\"                ConfigMap[:ruby_version])\\n\""
"\"    end\\n\""
"\"  end\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # Path for gems in the user's home directory\\n\""
"\"\\n\""
"\"  def self.user_dir\\n\""
"\"    File.join(Gem.user_home, '.gem', ruby_engine,\\n\""
"\"              ConfigMap[:ruby_version])\\n\""
"\"  end\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # Default gem load path\\n\""
"\"\\n\""
"\"  def self.default_path\\n\""
"\"    if File.exist?(Gem.user_home)\\n\""
"\"      [user_dir, default_dir]\\n\""
"\"    else\\n\""
"\"      [default_dir]\\n\""
"\"    end\\n\""
"\"  end\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # Deduce Ruby's --program-prefix and --program-suffix from its install name\\n\""
"\"\\n\""
"\"  def self.default_exec_format\\n\""
"\"    exec_format = ConfigMap[:ruby_install_name].sub('ruby', '%s') rescue '%s'\\n\""
"\"\\n\""
"\"    unless exec_format =~ /%s/ then\\n\""
"\"      raise Gem::Exception,\\n\""
"\"        \\\"[BUG] invalid exec_format \\#{exec_format.inspect}, no %s\\\"\\n\""
"\"    end\\n\""
"\"\\n\""
"\"    exec_format\\n\""
"\"  end\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # The default directory for binaries\\n\""
"\"\\n\""
"\"  def self.default_bindir\\n\""
"\"    if defined? RUBY_FRAMEWORK_VERSION then # mac framework support\\n\""
"\"      '/usr/bin'\\n\""
"\"    else # generic install\\n\""
"\"      ConfigMap[:bindir]\\n\""
"\"    end\\n\""
"\"  end\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # The default system-wide source info cache directory\\n\""
"\"\\n\""
"\"  def self.default_system_source_cache_dir\\n\""
"\"    File.join Gem.dir, 'source_cache'\\n\""
"\"  end\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # The default user-specific source info cache directory\\n\""
"\"\\n\""
"\"  def self.default_user_source_cache_dir\\n\""
"\"    File.join Gem.user_home, '.gem', 'source_cache'\\n\""
"\"  end\\n\""
"\"\\n\""
"\"  ##\\n\""
"\"  # A wrapper around RUBY_ENGINE const that may not be defined\\n\""
"\"\\n\""
"\"  def self.ruby_engine\\n\""
"\"    if defined? RUBY_ENGINE then\\n\""
"\"      RUBY_ENGINE\\n\""
"\"    else\\n\""
"\"      'ruby'\\n\""
"\"    end\\n\""
"\"  end\\n\""
"\"\\n\""
"\"end\\n\""
"\"\\n\""
", TOPLEVEL_BINDING, \"<internal:gem_prelude:defaults>\", 1)"
"    # end rubygems/defaults\n"
"\n"
"\n"
"    ##\n"
"    # Methods before this line will be removed when QuickLoader is replaced\n"
"    # with the real RubyGems\n"
"\n"
"    GEM_PRELUDE_METHODS = Gem.methods(false)\n"
"\n"
"    begin\n"
"      verbose, debug = $VERBOSE, $DEBUG\n"
"      $VERBOSE = $DEBUG = nil\n"
"\n"
"      begin\n"
"require 'rubygems/defaults/operating_system'\n"
"      rescue ::LoadError\n"
"      end\n"
"\n"
"      if defined?(RUBY_ENGINE) then\n"
"        begin\n"
"require \"rubygems/defaults/#{RUBY_ENGINE}\"\n"
"        rescue ::LoadError\n"
"        end\n"
"      end\n"
"    ensure\n"
"      $VERBOSE, $DEBUG = verbose, debug\n"
"    end\n"
"\n"
"    module QuickLoader\n"
"\n"
"      @loaded_full_rubygems_library = false\n"
"\n"
"      def self.load_full_rubygems_library\n"
"        return if @loaded_full_rubygems_library\n"
"\n"
"        @loaded_full_rubygems_library = true\n"
"\n"
"        class << Gem\n"
"          Gem::GEM_PRELUDE_METHODS.each do |method_name|\n"
"            undef_method method_name\n"
"          end\n"
"          undef_method :const_missing\n"
"          undef_method :method_missing\n"
"        end\n"
"\n"
"        Kernel.module_eval do\n"
"          undef_method :gem if method_defined? :gem\n"
"        end\n"
"\n"
"        $\".delete path_to_full_rubygems_library\n"
"        $\".each do |path|\n"
"          if /#{Regexp.escape File::SEPARATOR}rubygems\\.rb\\z/ =~ path\n"
"            raise LoadError, \"another rubygems is already loaded from #{path}\"\n"
"          end\n"
"        end\n"
"require 'rubygems'\n"
"      end\n"
"\n"
"      def self.fake_rubygems_as_loaded\n"
"        path = path_to_full_rubygems_library\n"
"        $\" << path unless $\".include?(path)\n"
"      end\n"
"\n"
"      def self.path_to_full_rubygems_library\n"
"        installed_path = File.join(Gem::ConfigMap[:rubylibprefix], Gem::ConfigMap[:ruby_version])\n"
"        if $:.include?(installed_path)\n"
"          return File.join(installed_path, 'rubygems.rb')\n"
"        else # e.g., on test-all\n"
"          $:.each do |dir|\n"
"            if File.exist?( path = File.join(dir, 'rubygems.rb') )\n"
"              return path\n"
"            end\n"
"          end\n"
"          raise LoadError, 'rubygems.rb'\n"
"        end\n"
"      end\n"
"\n"
"      GemPaths = {}\n"
"      GemVersions = {}\n"
"\n"
"      def push_gem_version_on_load_path(gem_name, *version_requirements)\n"
"        if version_requirements.empty?\n"
"          unless GemPaths.has_key?(gem_name) then\n"
"            raise Gem::LoadError, \"Could not find RubyGem #{gem_name} (>= 0)\\n\"\n"
"          end\n"
"\n"
"          # highest version gems already active\n"
"          return false\n"
"        else\n"
"          if version_requirements.length > 1 then\n"
"            QuickLoader.load_full_rubygems_library\n"
"            return gem(gem_name, *version_requirements)\n"
"          end\n"
"\n"
"          requirement, version = version_requirements[0].split\n"
"          requirement.strip!\n"
"\n"
"          if loaded_version = GemVersions[gem_name] then\n"
"            case requirement\n"
"            when \">\", \">=\" then\n"
"              return false if\n"
"                (loaded_version <=> Gem.integers_for(version)) >= 0\n"
"            when \"~>\" then\n"
"              required_version = Gem.integers_for version\n"
"\n"
"              return false if loaded_version.first == required_version.first\n"
"            end\n"
"          end\n"
"\n"
"          QuickLoader.load_full_rubygems_library\n"
"          gem gem_name, *version_requirements\n"
"        end\n"
"      end\n"
"\n"
"      def integers_for(gem_version)\n"
"        numbers = gem_version.split(\".\").collect {|n| n.to_i}\n"
"        numbers.pop while numbers.last == 0\n"
"        numbers << 0 if numbers.empty?\n"
"        numbers\n"
"      end\n"
"\n"
"      def push_all_highest_version_gems_on_load_path\n"
"        Gem.path.each do |path|\n"
"          gems_directory = File.join(path, \"gems\")\n"
"\n"
"          if File.exist?(gems_directory) then\n"
"            Dir.entries(gems_directory).each do |gem_directory_name|\n"
"              next if gem_directory_name == \".\" || gem_directory_name == \"..\"\n"
"\n"
"              dash = gem_directory_name.rindex(\"-\")\n"
"              next if dash.nil?\n"
"\n"
"              gem_name = gem_directory_name[0...dash]\n"
"              current_version = GemVersions[gem_name]\n"
"              new_version = integers_for(gem_directory_name[dash+1..-1])\n"
"\n"
"              if current_version then\n"
"                if (current_version <=> new_version) == -1 then\n"
"                  GemVersions[gem_name] = new_version\n"
"                  GemPaths[gem_name] = File.join(gems_directory, gem_directory_name)\n"
"                end\n"
"              else\n"
"                GemVersions[gem_name] = new_version\n"
"                GemPaths[gem_name] = File.join(gems_directory, gem_directory_name)\n"
"              end\n"
"            end\n"
"          end\n"
"        end\n"
"\n"
"        require_paths = []\n"
"\n"
"        GemPaths.each_value do |path|\n"
"          if File.exist?(file = File.join(path, \".require_paths\")) then\n"
"            paths = File.read(file).split.map do |require_path|\n"
"              File.join path, require_path\n"
"            end\n"
"\n"
"            require_paths.concat paths\n"
"          else\n"
"            require_paths << file if File.exist?(file = File.join(path, \"bin\"))\n"
"            require_paths << file if File.exist?(file = File.join(path, \"lib\"))\n"
"          end\n"
"        end\n"
"\n"
"        # \"tag\" the first require_path inserted into the $LOAD_PATH to enable\n"
"        # indexing correctly with rubygems proper when it inserts an explicitly\n"
"        # gem version\n"
"        unless require_paths.empty? then\n"
"          require_paths.first.instance_variable_set(:@gem_prelude_index, true)\n"
"        end\n"
"        # gem directories must come after -I and ENV['RUBYLIB']\n"
"        $:[$:.index(ConfigMap[:sitelibdir]),0] = require_paths\n"
"      end\n"
"\n"
"      def const_missing(constant)\n"
"        QuickLoader.load_full_rubygems_library\n"
"\n"
"        if Gem.const_defined?(constant) then\n"
"          Gem.const_get constant\n"
"        else\n"
"          super\n"
"        end\n"
"      end\n"
"\n"
"      def method_missing(method, *args, &block)\n"
"        QuickLoader.load_full_rubygems_library\n"
"        super unless Gem.respond_to?(method)\n"
"        Gem.send(method, *args, &block)\n"
"      end\n"
"    end\n"
"\n"
"    extend QuickLoader\n"
"\n"
"  end\n"
"\n"
"  begin\n"
"    Gem.push_all_highest_version_gems_on_load_path\n"
"    Gem::QuickLoader.fake_rubygems_as_loaded\n"
"  rescue Exception => e\n"
"    puts \"Error loading gem paths on load path in gem_prelude\"\n"
"    puts e\n"
"    puts e.backtrace.join(\"\\n\")\n"
"  end\n"
"\n"
"end\n"
"\n"
"Object.class_eval { remove_const \"TMP_RUBY_PREFIX\" }"
;

void
Init_prelude(void)
{
  rb_iseq_eval(rb_iseq_compile(
    rb_usascii_str_new(prelude_code0, sizeof(prelude_code0) - 1),
    rb_usascii_str_new(prelude_name0, sizeof(prelude_name0) - 1),
    INT2FIX(1)));

  rb_iseq_eval(rb_iseq_compile(
    rb_usascii_str_new(prelude_code1, sizeof(prelude_code1) - 1),
    rb_usascii_str_new(prelude_name1, sizeof(prelude_name1) - 1),
    INT2FIX(1)));

  rb_iseq_eval(rb_iseq_compile(
    rb_usascii_str_new(prelude_code2, sizeof(prelude_code2) - 1),
    rb_usascii_str_new(prelude_name2, sizeof(prelude_name2) - 1),
    INT2FIX(0)));

#if 0
    puts(prelude_code0);
    puts(prelude_code1);
    puts(prelude_code2);
#endif
}
