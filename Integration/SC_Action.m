/*
 *   ShinyCocos - ruby bindings for the cocos2d-iphone game framework
 *   Copyright (C) 2009, Rolando Abarca M.
 *
 *   This library is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU Lesser General Public
 *   License as published by the Free Software Foundation; either
 *   version 2.1 of the License.
 *
 *   This library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   Lesser General Public License for more details.
 *
 *   You should have received a copy of the GNU Lesser General Public
 *   License along with this library; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#import "SC_common.h"
#import "SC_Action.h"

VALUE rb_mActions;

// generated by
// cat cocos2d-iphone/cocos2d/*Action.h | grep @interface | ruby -ne 'md = $_.match(/@interface +(\w+) *: *(\w+)/); puts "VALUE rb_c#{md[1]}; // #{md[2]}" if md'
VALUE rb_cAction; // NSObject
VALUE rb_cFiniteTimeAction; // Action
VALUE rb_cRepeatForever; // Action
VALUE rb_cSpeed; // Action
VALUE rb_cCameraAction; // IntervalAction
VALUE rb_cOrbitCamera; // CameraAction
VALUE rb_cEaseAction; // IntervalAction
VALUE rb_cEaseRateAction; // EaseAction
VALUE rb_cEaseIn; // EaseRateAction
VALUE rb_cEaseOut; // EaseRateAction
VALUE rb_cEaseInOut; // EaseRateAction
VALUE rb_cEaseExponentialIn; // EaseAction
VALUE rb_cEaseExponentialOut; // EaseAction
VALUE rb_cEaseExponentialInOut; // EaseAction
VALUE rb_cEaseSineIn; // EaseAction
VALUE rb_cEaseSineOut; // EaseAction
VALUE rb_cEaseSineInOut; // EaseAction
VALUE rb_cWaves3D; // Grid3DAction
VALUE rb_cFlipX3D; // Grid3DAction
VALUE rb_cFlipY3D; // FlipX3D
VALUE rb_cLens3D; // Grid3DAction
VALUE rb_cRipple3D; // Grid3DAction
VALUE rb_cShaky3D; // Grid3DAction
VALUE rb_cLiquid; // Grid3DAction
VALUE rb_cWaves; // Grid3DAction
VALUE rb_cTwirl; // Grid3DAction
VALUE rb_cGridAction; // IntervalAction
VALUE rb_cGrid3DAction; // GridAction
VALUE rb_cTiledGrid3DAction; // GridAction
VALUE rb_cAccelDeccelAmplitude; // IntervalAction
VALUE rb_cAccelAmplitude; // IntervalAction
VALUE rb_cDeccelAmplitude; // IntervalAction
VALUE rb_cStopGrid; // InstantAction
VALUE rb_cReuseGrid; // InstantAction
VALUE rb_cInstantAction; // FiniteTimeAction
VALUE rb_cShow; // InstantAction
VALUE rb_cHide; // InstantAction
VALUE rb_cToggleVisibility; // InstantAction
VALUE rb_cPlace; // InstantAction
VALUE rb_cCallFunc; // InstantAction
VALUE rb_cCallFuncN; // CallFunc
VALUE rb_cCallFuncND; // CallFuncN
VALUE rb_cIntervalAction; // FiniteTimeAction
VALUE rb_cSequence; // IntervalAction
VALUE rb_cRepeat; // IntervalAction
VALUE rb_cSpawn; // IntervalAction
VALUE rb_cRotateTo; // IntervalAction
VALUE rb_cRotateBy; // IntervalAction
VALUE rb_cMoveTo; // IntervalAction
VALUE rb_cMoveBy; // MoveTo
VALUE rb_cJumpBy; // IntervalAction
VALUE rb_cJumpTo; // JumpBy
VALUE rb_cBezierBy; // IntervalAction
VALUE rb_cScaleTo; // IntervalAction
VALUE rb_cScaleBy; // ScaleTo
VALUE rb_cBlink; // IntervalAction
VALUE rb_cFadeIn; // IntervalAction
VALUE rb_cFadeOut; // IntervalAction
VALUE rb_cFadeTo; // IntervalAction
VALUE rb_cTintTo; // IntervalAction
VALUE rb_cTintBy; // IntervalAction
VALUE rb_cDelayTime; // IntervalAction
VALUE rb_cReverseTime; // IntervalAction
VALUE rb_cAnimate; // IntervalAction
VALUE rb_cShakyTiles3D; // TiledGrid3DAction
VALUE rb_cShatteredTiles3D; // TiledGrid3DAction
VALUE rb_cShuffleTiles; // TiledGrid3DAction
VALUE rb_cFadeOutTRTiles; // TiledGrid3DAction
VALUE rb_cFadeOutBLTiles; // FadeOutTRTiles
VALUE rb_cFadeOutUpTiles; // FadeOutTRTiles
VALUE rb_cFadeOutDownTiles; // FadeOutUpTiles
VALUE rb_cTurnOffTiles; // TiledGrid3DAction
VALUE rb_cWavesTiles3D; // TiledGrid3DAction
VALUE rb_cJumpTiles3D; // TiledGrid3DAction
VALUE rb_cSplitRows; // TiledGrid3DAction
VALUE rb_cSplitCols; // TiledGrid3DAction


# pragma mark Action Extension

@interface Action (SC_Extension)
- (void)rb_stop;
@end

@implementation Action (SC_Extension)
- (void)rb_stop {
	[self rb_stop];
	if (userData) {
		sc_protect_funcall((VALUE)userData, id_sc_on_stop, 0, 0);
	}
}
@end


#pragma mark Action

/*
 * call-seq:
 *   Action.new   #=> new action
 */
VALUE rb_cAction_s_new(int argc, VALUE *argv, VALUE klass) {
	Action *action = [[Action alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	action.userData = (void *)ret;
	return ret;
}


/*
 * call-seq:
 *   action.start_with_target   #=> nil
 *
 * starts running the action
 */
VALUE rb_cAction_start_with_target(VALUE object, VALUE target) {
	[CC_ACTION(object) startWithTarget:CC_NODE(target)];
	return Qnil;
}


/*
 * call-seq:
 *   action.target   #=> cocos node
 *
 * returns the target of the specified action.
 */
VALUE rb_cAction_target(VALUE object) {
	CocosNode *target = CC_ACTION(object);
	if (target.userData) {
		return (VALUE)(target.userData);
	}
	return Qnil;
}


/*
 * call-seq:
 *   action.stop   #=> nil
 *
 * stops the running action
 */
VALUE rb_cAction_stop(VALUE object) {
	[CC_ACTION(object) stop];
	return Qnil;
}


/*
 * call-seq:
 *   action.done?   #=> true/false
 *
 * returns true if the action is done
 */
VALUE rb_cAction_done_p(VALUE object) {
	return [CC_ACTION(object) isDone] ? Qtrue : Qfalse;
}

// base init code (just the basic +new+ method) created by:
/*
cat cocos2d-iphone/cocos2d/*Action.h |\
grep @interface |\
ruby -ne 'md = $_.match(/@interface +(\w+) *: *(\w+)/); puts "VALUE rb_c#{md[1]}_s_new(int argc, VALUE *argv, VALUE klass) {\n\t#{md[1]} *action = [[#{md[1]} alloc] init];\n\tVALUE ret = sc_init(klass, nil, action, argc, argv, YES);\n\treturn ret;\n}\n\n\n" if md'
*/

/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFiniteTimeAction_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	FiniteTimeAction *action = [[FiniteTimeAction alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFiniteTimeAction_duration(VALUE object) {
	return rb_float_new(CC_FINITETIMEACTION(object).duration);
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFiniteTimeAction_set_duration(VALUE object, VALUE d) {
	CC_FINITETIMEACTION(object).duration = NUM2DBL(d);
	return d;
}


/*
 * call-seq:
 *   action2 = action1.reverse   #=> action
 *
 * returns the reverse action (only for finite time actions)
 */
VALUE rb_cFiniteTimeAction_reverse(VALUE object) {
	FiniteTimeAction *action = [CC_FINITETIMEACTION(object) reverse];
	if (action) {
		return sc_ruby_instance_for(sc_object_hash, action);
	}
	return Qnil;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cRepeatForever_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(1, rb_cIntervalAction)
	RepeatForever *action = [[RepeatForever alloc] initWithAction:CC_INTERVALACTION(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cSpeed_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(2, rb_cIntervalAction)
	Speed *action = [[Speed alloc] initWithAction:CC_INTERVALACTION(argv[0]) speed:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cSpeed_speed(VALUE object) {
	return rb_float_new(CC_SPEED(object).speed);
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cSpeed_set_speed(VALUE object, VALUE speed) {
	CC_SPEED(object).speed = NUM2DBL(speed);
	return speed;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cCameraAction_s_new(int argc, VALUE *argv, VALUE klass) {
	CameraAction *action = [[CameraAction alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 * OrbitCamera.new(duration, radius, delta_radius, angle_z, delta_angle_z, angle_x, delta_angle_x)   #=> OrbitCamera instance
 */
VALUE rb_cOrbitCamera_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(7)
	OrbitCamera *action = [[OrbitCamera alloc] initWithDuration:NUM2DBL(argv[0])
														 radius:NUM2DBL(argv[1])
													deltaRadius:NUM2DBL(argv[2])
														 angleZ:NUM2DBL(argv[3])
													deltaAngleZ:NUM2DBL(argv[4])
														 angleX:NUM2DBL(argv[5])
													deltaAngleX:NUM2DBL(argv[6])];
	VALUE ret = sc_init(klass, nil, action, argc-7, argv+7, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cEaseAction_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(1, rb_cIntervalAction)
	EaseAction *action = [[EaseAction alloc] initWithAction:CC_INTERVALACTION(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cEaseRateAction_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(2, rb_cIntervalAction)
	EaseRateAction *action = [[EaseRateAction alloc] initWithAction:CC_INTERVALACTION(argv[0]) rate:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}




/* 
 * call-seq:
 *   Actions::EaseIn.new another_action
 *
 * example:
 *   node.run_action Actions::EaseIn.new(Actions::MoveTo.new(10, [20,20]))
 */
VALUE rb_cEaseIn_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(1, rb_cIntervalAction)
	EaseIn *action = [[EaseIn alloc]  initWithAction:CC_INTERVALACTION(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/* 
 * call-seq:
 *   Actions::EaseOut.new another_action
 *
 * example:
 *   node.run_action Actions::EaseOut.new(Actions::MoveTo.new(10, [20,20]))
 */
VALUE rb_cEaseOut_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(1, rb_cIntervalAction)
	EaseOut *action = [[EaseOut alloc]  initWithAction:CC_INTERVALACTION(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
	
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cEaseInOut_s_new(int argc, VALUE *argv, VALUE klass) {
	EaseInOut *action = [[EaseInOut alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/* 
 * call-seq:
 *   Actions::EaseExponentialIn.new another_action
 *
 * example:
 *   node.run_action Actions::EaseExponentialIn.new(Actions::MoveTo.new(10, [20,20]))
 */
VALUE rb_cEaseExponentialIn_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(1, rb_cIntervalAction)
	EaseExponentialIn *action = [[EaseExponentialIn alloc]  initWithAction:CC_INTERVALACTION(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/* 
 * call-seq:
 *   Actions::EaseExponentialOut.new another_action
 *
 * example:
 *   node.run_action Actions::EaseExponentialOut.new(Actions::MoveTo.new(10, [20,20]))
 */
VALUE rb_cEaseExponentialOut_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(1, rb_cIntervalAction)
	EaseExponentialOut *action = [[EaseExponentialOut alloc]  initWithAction:CC_INTERVALACTION(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}



/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cEaseExponentialInOut_s_new(int argc, VALUE *argv, VALUE klass) {
	EaseExponentialInOut *action = [[EaseExponentialInOut alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cEaseSineIn_s_new(int argc, VALUE *argv, VALUE klass) {
	EaseSineIn *action = [[EaseSineIn alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cEaseSineOut_s_new(int argc, VALUE *argv, VALUE klass) {
	EaseSineOut *action = [[EaseSineOut alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cEaseSineInOut_s_new(int argc, VALUE *argv, VALUE klass) {
	EaseSineInOut *action = [[EaseSineInOut alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cGridAction_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(2)
	Check_Type(argv[0], T_ARRAY);
	
	ccGridSize gridSize;
	gridSize.x = FIX2INT(RARRAY_PTR(argv[0])[0]);
	gridSize.y = FIX2INT(RARRAY_PTR(argv[0])[1]);
	GridAction *action = [[GridAction alloc] initWithSize:gridSize duration:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cGrid3DAction_s_new(int argc, VALUE *argv, VALUE klass) {
	Grid3DAction *action = [[Grid3DAction alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cTiledGrid3DAction_s_new(int argc, VALUE *argv, VALUE klass) {
	TiledGrid3DAction *action = [[TiledGrid3DAction alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cAccelDeccelAmplitude_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(2, rb_cAction)
	AccelDeccelAmplitude *action = [[AccelDeccelAmplitude alloc] initWithAction:CC_ACTION(argv[0]) duration:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cAccelAmplitude_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(2, rb_cAction)
	AccelAmplitude *action = [[AccelAmplitude alloc] initWithAction:CC_ACTION(argv[0]) duration:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cDeccelAmplitude_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(2, rb_cAction)
	DeccelAmplitude *action = [[DeccelAmplitude alloc] initWithAction:CC_ACTION(argv[0]) duration:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cStopGrid_s_new(int argc, VALUE *argv, VALUE klass) {
	StopGrid *action = [[StopGrid alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cReuseGrid_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	ReuseGrid *action = [[ReuseGrid alloc] initWithTimes:FIX2INT(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cWaves3D_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(4)
	Check_Type(argv[2], T_ARRAY);
	ccGridSize gridSize;
	gridSize.x = FIX2INT(RARRAY_PTR(argv[2])[0]);
	gridSize.y = FIX2INT(RARRAY_PTR(argv[2])[1]);
	Waves3D *action = [[Waves3D alloc] initWithWaves:FIX2INT(argv[0]) amplitude:NUM2DBL(argv[1]) grid:gridSize duration:NUM2DBL(argv[3])];
	VALUE ret = sc_init(klass, nil, action, argc-4, argv+4, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFlipX3D_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	FlipX3D *action = [[FlipX3D alloc] initWithDuration:NUM2DBL(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFlipY3D_s_new(int argc, VALUE *argv, VALUE klass) {
	FlipY3D *action = [[FlipY3D alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cLens3D_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(4)
	Check_Type(argv[0], T_ARRAY);
	Check_Type(argv[2], T_ARRAY);
	CGPoint p;
	p.x = NUM2DBL(RARRAY_PTR(argv[0])[0]);
	p.y = NUM2DBL(RARRAY_PTR(argv[0])[1]);
	ccGridSize gridSize;
	gridSize.x = FIX2INT(RARRAY_PTR(argv[2])[0]);
	gridSize.y = FIX2INT(RARRAY_PTR(argv[2])[1]);
	Lens3D *action = [[Lens3D alloc] initWithPosition:p radius:NUM2DBL(argv[1]) grid:gridSize duration:NUM2DBL(argv[3])];
	VALUE ret = sc_init(klass, nil, action, argc-4, argv+4, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cRipple3D_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	Ripple3D *action = [[Ripple3D alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cShaky3D_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	Shaky3D *action = [[Shaky3D alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cLiquid_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	Liquid *action = [[Liquid alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cWaves_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	Waves *action = [[Waves alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cTwirl_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	Twirl *action = [[Twirl alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cInstantAction_s_new(int argc, VALUE *argv, VALUE klass) {
	InstantAction *action = [[InstantAction alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cShow_s_new(int argc, VALUE *argv, VALUE klass) {
	Show *action = [[Show alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cHide_s_new(int argc, VALUE *argv, VALUE klass) {
	Hide *action = [[Hide alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cToggleVisibility_s_new(int argc, VALUE *argv, VALUE klass) {
	ToggleVisibility *action = [[ToggleVisibility alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cPlace_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	CGPoint p;
	p.x = NUM2DBL(RARRAY_PTR(argv[0])[0]);
	p.y = NUM2DBL(RARRAY_PTR(argv[0])[1]);
	Place *action = [[Place alloc] initWithPosition:p];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cCallFunc_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	CallFunc *action = [[CallFunc alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cCallFuncN_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	CallFuncN *action = [[CallFuncN alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cCallFuncND_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	CallFuncND *action = [[CallFuncND alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cIntervalAction_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	IntervalAction *action = [[IntervalAction alloc] initWithDuration:NUM2DBL(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/*
 * call-seq:
 *   action = Actions::Sequence.new(*list)   #=> action
 *
 * creates a new action given a list of actions. Each one is executed right after the other
 */
VALUE rb_cSequence_s_new(int argc, VALUE *argv, VALUE klass) {
	// we create a sequence with each two actions from the argument list
	Sequence *action, *first = nil;
	int i = 0;
	while (i < argc) {
		if (!first) {
			first = [[Sequence alloc] initOne:CC_FINITETIMEACTION(argv[i++]) two:CC_FINITETIMEACTION(argv[i++])];
			action = first;
			argc -= 2;
		} else {
			first = [[Sequence alloc] initOne:first two:CC_FINITETIMEACTION(argv[i++])];
			argc -= 1;
		}
	}
	// we only keep the top sequence associated to ruby
	VALUE ret = sc_init(klass, nil, action, argc, argv+i, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cRepeat_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM_AND_SUBCLASS(2, rb_cFiniteTimeAction)
	Repeat *action = [[Repeat alloc] initWithAction:CC_FINITETIMEACTION(argv[0]) times:FIX2INT(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   action = Actions::Spawn.new(*list)   #=> action
 *
 * same as sequence, but actions are executed simultaneously
 */
VALUE rb_cSpawn_s_new(int argc, VALUE *argv, VALUE klass) {
	Spawn *action, *first = nil;
	int i = 0;
	while (i < argc) {
		if (!first) {
			first = [[Spawn alloc] initOne:CC_FINITETIMEACTION(argv[i++]) two:CC_FINITETIMEACTION(argv[i++])];
			action = first;
			argc -= 2;
		} else {
			first = [[Spawn alloc] initOne:first two:CC_FINITETIMEACTION(argv[i++])];
			argc -= 1;
		}
	}
	// we only keep the top spawn associated to ruby
	VALUE ret = sc_init(klass, nil, action, argc, argv+i, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cRotateTo_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(2)
	RotateTo *action = [[RotateTo alloc] initWithDuration:NUM2DBL(argv[0]) angle:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cRotateBy_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(2)
	RotateBy *action = [[RotateBy alloc] initWithDuration:NUM2DBL(argv[0]) angle:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   action = Cocos2D::Actions::MoveTo.new(duration, [x,y])   #=> Action
 *
 * move-to
 */
VALUE rb_cMoveTo_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(2)
	Check_Type(argv[1], T_ARRAY);
	CGPoint p;
	p.x = NUM2DBL(RARRAY_PTR(argv[1])[0]);
	p.y = NUM2DBL(RARRAY_PTR(argv[1])[1]);
	MoveTo *action = [[MoveTo alloc] initWithDuration:NUM2DBL(argv[0]) position:p];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	action.userData = (void *)ret;
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cMoveBy_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(2)
	Check_Type(argv[1], T_ARRAY);
	CGPoint p;
	p.x = NUM2DBL(RARRAY_PTR(argv[1])[0]);
	p.y = NUM2DBL(RARRAY_PTR(argv[1])[1]);
	MoveBy *action = [[MoveBy alloc] initWithDuration:NUM2DBL(argv[0]) position:p];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	action.userData = (void *)ret;
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cJumpBy_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(4)
	Check_Type(argv[1], T_ARRAY);
	CGPoint p;
	p.x = NUM2DBL(RARRAY_PTR(argv[1])[0]);
	p.y = NUM2DBL(RARRAY_PTR(argv[1])[1]);
	JumpBy *action = [[JumpBy alloc] initWithDuration:NUM2DBL(argv[0]) position:p height:NUM2DBL(argv[2]) jumps:FIX2INT(argv[3])];
	VALUE ret = sc_init(klass, nil, action, argc-4, argv+4, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cJumpTo_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(4)
	Check_Type(argv[1], T_ARRAY);
	CGPoint p;
	p.x = NUM2DBL(RARRAY_PTR(argv[1])[0]);
	p.y = NUM2DBL(RARRAY_PTR(argv[1])[1]);
	JumpTo *action = [[JumpTo alloc] initWithDuration:NUM2DBL(argv[0]) position:p height:NUM2DBL(argv[2]) jumps:FIX2INT(argv[3])];
	VALUE ret = sc_init(klass, nil, action, argc-4, argv+4, YES);
	return ret;
}


/* 
 * call-seq:
 *   Actions::BezierBy.new duration, start_pos, cntrl_pt_1, cntrl_pt_2, end_pos
 *
 * example:
 *   node.run_action Actions::BezierBy.new(5, [0,0], [-20,40], [30,-50], [20,20])
 * 
 * Generate BezierBy action, for moving a sprite along a Bezier curve..
 * It's a DoBy action, so all points are relative to the starting position of the node..
VALUE rb_cBezierBy_s_new(int argc, VALUE *argv, VALUE klass) {
	
	CHECK_ARGS_NUM(5)
	Check_Type(argv[1], T_ARRAY);
	Check_Type(argv[2], T_ARRAY);
	Check_Type(argv[3], T_ARRAY);
	Check_Type(argv[4], T_ARRAY);
	
	ccBezierConfig config;
	
	config.startPosition	= cpv(NUM2DBL(RARRAY_PTR(argv[1])[0]), NUM2DBL(RARRAY_PTR(argv[1])[1]));
	config.controlPoint_1	= cpv(NUM2DBL(RARRAY_PTR(argv[2])[0]), NUM2DBL(RARRAY_PTR(argv[2])[1]));
	config.controlPoint_2	= cpv(NUM2DBL(RARRAY_PTR(argv[3])[0]), NUM2DBL(RARRAY_PTR(argv[3])[1]));
	config.endPosition		= cpv(NUM2DBL(RARRAY_PTR(argv[4])[0]), NUM2DBL(RARRAY_PTR(argv[4])[1]));
	
	BezierBy *action = [[BezierBy alloc] initWithDuration: NUM2DBL(argv[0]) bezier: config];
	VALUE ret = sc_init(klass, nil, action, argc-5, argv+5, YES);
	return ret;
}
*/


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cScaleTo_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(3)
	ScaleTo *action = [[ScaleTo alloc] initWithDuration:NUM2DBL(argv[0]) scaleX:NUM2DBL(argv[1]) scaleY:NUM2DBL(argv[2])];
	VALUE ret = sc_init(klass, nil, action, argc-3, argv+3, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cScaleBy_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(3)
	ScaleBy *action = [[ScaleBy alloc] initWithDuration:NUM2DBL(argv[0]) scaleX:NUM2DBL(argv[1]) scaleY:NUM2DBL(argv[2])];
	VALUE ret = sc_init(klass, nil, action, argc-3, argv+3, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cBlink_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	Blink *action = [[Blink alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   act = Cocos2D::Actions::FadeIn.new()  #=> action
 *
 * fade in
 */
VALUE rb_cFadeIn_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	FadeIn *action = [[FadeIn alloc] initWithDuration:NUM2DBL(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	action.userData = (void *)ret;
	return ret;
}


/*
 * call-seq:
 *   act = Cocos2D::Actions::FadeOut.new()  #=> action
 *
 * fade out
 */
VALUE rb_cFadeOut_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	FadeOut *action = [[FadeOut alloc] initWithDuration:NUM2DBL(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	action.userData = (void *)ret;
	return ret;
}


/*
 * call-seq:
 *   action = Actions::FadeTo.new(duration, opacity)   #=> action
 *
 * fades to the desired opacity (alpha channel)
 */
VALUE rb_cFadeTo_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(2)
	FadeTo *action = [[FadeTo alloc] initWithDuration:NUM2DBL(argv[0]) opacity:NUM2DBL(argv[1])];
	VALUE ret = sc_init(klass, nil, action, argc-2, argv+2, YES);
	return ret;
}


/*
 * call-seq:
 *   action = Actions::TintTo.new(duration, r, g, b)   #=> action
 *
 * creates a TintTo action.
 */
VALUE rb_cTintTo_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(4)
	TintTo *action = [[TintTo alloc] initWithDuration:NUM2DBL(argv[0]) red:NUM2DBL(argv[1]) green:NUM2DBL(argv[2]) blue:NUM2DBL(argv[3])];
	VALUE ret = sc_init(klass, nil, action, argc-4, argv+4, YES);
	return ret;
}


/*
 * call-seq:
 *   action = Actions::TintBy.new(duration, r, g, b)   #=> action
 *
 * createas a TintBy action.
 */
VALUE rb_cTintBy_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(4)
	TintBy *action = [[TintBy alloc] initWithDuration:NUM2DBL(argv[0]) red:NUM2DBL(argv[1]) green:NUM2DBL(argv[2]) blue:NUM2DBL(argv[3])];
	VALUE ret = sc_init(klass, nil, action, argc-4, argv+4, YES);
	return ret;
}


/*
 * call-seq:
 *   action = Actions::DelayTime.new(duration)   #=> action
 *
 * dummy action
 */
VALUE rb_cDelayTime_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	DelayTime *action = [[DelayTime alloc] initWithDuration:NUM2DBL(argv[0])];
	VALUE ret = sc_init(klass, nil, action, argc-1, argv+1, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cReverseTime_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	ReverseTime *action = [[ReverseTime alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   node.run_action(Cocos2D::Animate.new(animation, true))  #=> run animation and restore original frame
 *   node.run_action(Cocos2D::Animate.new(animation))        #=> run animation and do not original frame
 *
 * Second parameter is optional. By default it's false.
 */
VALUE rb_cAnimate_s_new(int argc, VALUE *argv, VALUE klass) {
	CHECK_ARGS_NUM(1)
	Animate *action;
	if (argc == 2) {
		action = [[Animate alloc] initWithAnimation:(id<CocosAnimation>)sc_get_objc(argv[0]) restoreOriginalFrame:((argv[1]) != Qfalse ? YES : NO)];
		argc -= 2;
		argv += 2;
	} else {
		action = [[Animate alloc] initWithAnimation:(id<CocosAnimation>)sc_get_objc(argv[0])];
		argc -= 1;
		argv += 1;
	}
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	action.userData = (void *)ret;
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cShakyTiles3D_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	ShakyTiles3D *action = [[ShakyTiles3D alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cShatteredTiles3D_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	ShatteredTiles3D *action = [[ShatteredTiles3D alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cShuffleTiles_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	ShuffleTiles *action = [[ShuffleTiles alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFadeOutTRTiles_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	FadeOutTRTiles *action = [[FadeOutTRTiles alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFadeOutBLTiles_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	FadeOutBLTiles *action = [[FadeOutBLTiles alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFadeOutUpTiles_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	FadeOutUpTiles *action = [[FadeOutUpTiles alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cFadeOutDownTiles_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	FadeOutDownTiles *action = [[FadeOutDownTiles alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cTurnOffTiles_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	TurnOffTiles *action = [[TurnOffTiles alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cWavesTiles3D_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	WavesTiles3D *action = [[WavesTiles3D alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cJumpTiles3D_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	JumpTiles3D *action = [[JumpTiles3D alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cSplitRows_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	SplitRows *action = [[SplitRows alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}


/*
 * call-seq:
 *   doc stub
 */
VALUE rb_cSplitCols_s_new(int argc, VALUE *argv, VALUE klass) {
	rb_raise(rb_eStandardError, "Action not implemented (%d)", rb_class2name(klass));
	SplitCols *action = [[SplitCols alloc] init];
	VALUE ret = sc_init(klass, nil, action, argc, argv, YES);
	return ret;
}



#pragma mark Init Action

void init_rb_mAction() {
	rb_mActions = rb_define_module_under(rb_mCocos2D, "Actions");

	// base action class
	rb_cAction = rb_define_class_under(rb_mActions, "Action", rb_cObject);
	rb_define_singleton_method(rb_cAction, "new", rb_cAction_s_new, -1);
	// common action methods
	rb_define_method(rb_cAction, "start_with_target", rb_cAction_start_with_target, 1);
	rb_define_method(rb_cAction, "stop", rb_cAction_stop, 0);
	rb_define_method(rb_cAction, "target", rb_cAction_target, 0);
	rb_define_method(rb_cAction, "done?", rb_cAction_done_p, 0);

	// action subclasses
	// cat cocos2d-iphone/cocos2d/*Action.h | grep @interface | ruby -ne 'md = $_.match(/@interface +(\w+) *: *(\w+)/); puts "\trb_c#{md[1]} = rb_define_class_under(rb_mActions, \"#{md[1]}\", rb_c#{md[2]}); // #{md[1]}" if md'
	rb_cFiniteTimeAction = rb_define_class_under(rb_mActions, "FiniteTimeAction", rb_cAction); // FiniteTimeAction
	rb_cRepeatForever = rb_define_class_under(rb_mActions, "RepeatForever", rb_cAction); // RepeatForever
	rb_cSpeed = rb_define_class_under(rb_mActions, "Speed", rb_cAction); // Speed
	rb_cIntervalAction = rb_define_class_under(rb_mActions, "IntervalAction", rb_cFiniteTimeAction); // IntervalAction
	rb_cSequence = rb_define_class_under(rb_mActions, "Sequence", rb_cIntervalAction); // Sequence
	rb_cRepeat = rb_define_class_under(rb_mActions, "Repeat", rb_cIntervalAction); // Repeat
	rb_cSpawn = rb_define_class_under(rb_mActions, "Spawn", rb_cIntervalAction); // Spawn
	rb_cRotateTo = rb_define_class_under(rb_mActions, "RotateTo", rb_cIntervalAction); // RotateTo
	rb_cRotateBy = rb_define_class_under(rb_mActions, "RotateBy", rb_cIntervalAction); // RotateBy
	rb_cMoveTo = rb_define_class_under(rb_mActions, "MoveTo", rb_cIntervalAction); // MoveTo
	rb_cMoveBy = rb_define_class_under(rb_mActions, "MoveBy", rb_cMoveTo); // MoveBy
	rb_cJumpBy = rb_define_class_under(rb_mActions, "JumpBy", rb_cIntervalAction); // JumpBy
	rb_cJumpTo = rb_define_class_under(rb_mActions, "JumpTo", rb_cJumpBy); // JumpTo
//	rb_cBezierBy = rb_define_class_under(rb_mActions, "BezierBy", rb_cIntervalAction); // BezierBy
	rb_cScaleTo = rb_define_class_under(rb_mActions, "ScaleTo", rb_cIntervalAction); // ScaleTo
	rb_cScaleBy = rb_define_class_under(rb_mActions, "ScaleBy", rb_cScaleTo); // ScaleBy
	rb_cBlink = rb_define_class_under(rb_mActions, "Blink", rb_cIntervalAction); // Blink
	rb_cFadeIn = rb_define_class_under(rb_mActions, "FadeIn", rb_cIntervalAction); // FadeIn
	rb_cFadeOut = rb_define_class_under(rb_mActions, "FadeOut", rb_cIntervalAction); // FadeOut
	rb_cFadeTo = rb_define_class_under(rb_mActions, "FadeTo", rb_cIntervalAction); // FadeTo
	rb_cTintTo = rb_define_class_under(rb_mActions, "TintTo", rb_cIntervalAction); // TintTo
	rb_cTintBy = rb_define_class_under(rb_mActions, "TintBy", rb_cIntervalAction); // TintBy
	rb_cDelayTime = rb_define_class_under(rb_mActions, "DelayTime", rb_cIntervalAction); // DelayTime
	rb_cReverseTime = rb_define_class_under(rb_mActions, "ReverseTime", rb_cIntervalAction); // ReverseTime
	rb_cAnimate = rb_define_class_under(rb_mActions, "Animate", rb_cIntervalAction); // Animate
	rb_cCameraAction = rb_define_class_under(rb_mActions, "CameraAction", rb_cIntervalAction); // CameraAction
	rb_cOrbitCamera = rb_define_class_under(rb_mActions, "OrbitCamera", rb_cCameraAction); // OrbitCamera
	rb_cEaseAction = rb_define_class_under(rb_mActions, "EaseAction", rb_cIntervalAction); // EaseAction
	rb_cEaseRateAction = rb_define_class_under(rb_mActions, "EaseRateAction", rb_cEaseAction); // EaseRateAction
	rb_cEaseIn = rb_define_class_under(rb_mActions, "EaseIn", rb_cEaseRateAction); // EaseIn
	rb_cEaseOut = rb_define_class_under(rb_mActions, "EaseOut", rb_cEaseRateAction); // EaseOut
	rb_cEaseInOut = rb_define_class_under(rb_mActions, "EaseInOut", rb_cEaseRateAction); // EaseInOut
	rb_cEaseExponentialIn = rb_define_class_under(rb_mActions, "EaseExponentialIn", rb_cEaseAction); // EaseExponentialIn
	rb_cEaseExponentialOut = rb_define_class_under(rb_mActions, "EaseExponentialOut", rb_cEaseAction); // EaseExponentialOut
	rb_cEaseExponentialInOut = rb_define_class_under(rb_mActions, "EaseExponentialInOut", rb_cEaseAction); // EaseExponentialInOut
	rb_cEaseSineIn = rb_define_class_under(rb_mActions, "EaseSineIn", rb_cEaseAction); // EaseSineIn
	rb_cEaseSineOut = rb_define_class_under(rb_mActions, "EaseSineOut", rb_cEaseAction); // EaseSineOut
	rb_cEaseSineInOut = rb_define_class_under(rb_mActions, "EaseSineInOut", rb_cEaseAction); // EaseSineInOut
	rb_cInstantAction = rb_define_class_under(rb_mActions, "InstantAction", rb_cFiniteTimeAction); // InstantAction
	rb_cShow = rb_define_class_under(rb_mActions, "Show", rb_cInstantAction); // Show
	rb_cHide = rb_define_class_under(rb_mActions, "Hide", rb_cInstantAction); // Hide
	rb_cToggleVisibility = rb_define_class_under(rb_mActions, "ToggleVisibility", rb_cInstantAction); // ToggleVisibility
	rb_cPlace = rb_define_class_under(rb_mActions, "Place", rb_cInstantAction); // Place
	rb_cCallFunc = rb_define_class_under(rb_mActions, "CallFunc", rb_cInstantAction); // CallFunc
	rb_cCallFuncN = rb_define_class_under(rb_mActions, "CallFuncN", rb_cCallFunc); // CallFuncN
	rb_cCallFuncND = rb_define_class_under(rb_mActions, "CallFuncND", rb_cCallFuncN); // CallFuncND
	rb_cGridAction = rb_define_class_under(rb_mActions, "GridAction", rb_cIntervalAction); // GridAction
	rb_cGrid3DAction = rb_define_class_under(rb_mActions, "Grid3DAction", rb_cGridAction); // Grid3DAction
	rb_cTiledGrid3DAction = rb_define_class_under(rb_mActions, "TiledGrid3DAction", rb_cGridAction); // TiledGrid3DAction
	rb_cAccelDeccelAmplitude = rb_define_class_under(rb_mActions, "AccelDeccelAmplitude", rb_cIntervalAction); // AccelDeccelAmplitude
	rb_cAccelAmplitude = rb_define_class_under(rb_mActions, "AccelAmplitude", rb_cIntervalAction); // AccelAmplitude
	rb_cDeccelAmplitude = rb_define_class_under(rb_mActions, "DeccelAmplitude", rb_cIntervalAction); // DeccelAmplitude
	rb_cStopGrid = rb_define_class_under(rb_mActions, "StopGrid", rb_cInstantAction); // StopGrid
	rb_cReuseGrid = rb_define_class_under(rb_mActions, "ReuseGrid", rb_cInstantAction); // ReuseGrid
	rb_cWaves3D = rb_define_class_under(rb_mActions, "Waves3D", rb_cGrid3DAction); // Waves3D
	rb_cFlipX3D = rb_define_class_under(rb_mActions, "FlipX3D", rb_cGrid3DAction); // FlipX3D
	rb_cFlipY3D = rb_define_class_under(rb_mActions, "FlipY3D", rb_cFlipX3D); // FlipY3D
	rb_cLens3D = rb_define_class_under(rb_mActions, "Lens3D", rb_cGrid3DAction); // Lens3D
	rb_cRipple3D = rb_define_class_under(rb_mActions, "Ripple3D", rb_cGrid3DAction); // Ripple3D
	rb_cShaky3D = rb_define_class_under(rb_mActions, "Shaky3D", rb_cGrid3DAction); // Shaky3D
	rb_cLiquid = rb_define_class_under(rb_mActions, "Liquid", rb_cGrid3DAction); // Liquid
	rb_cWaves = rb_define_class_under(rb_mActions, "Waves", rb_cGrid3DAction); // Waves
	rb_cTwirl = rb_define_class_under(rb_mActions, "Twirl", rb_cGrid3DAction); // Twirl
	rb_cShakyTiles3D = rb_define_class_under(rb_mActions, "ShakyTiles3D", rb_cTiledGrid3DAction); // ShakyTiles3D
	rb_cShatteredTiles3D = rb_define_class_under(rb_mActions, "ShatteredTiles3D", rb_cTiledGrid3DAction); // ShatteredTiles3D
	rb_cShuffleTiles = rb_define_class_under(rb_mActions, "ShuffleTiles", rb_cTiledGrid3DAction); // ShuffleTiles
	rb_cFadeOutTRTiles = rb_define_class_under(rb_mActions, "FadeOutTRTiles", rb_cTiledGrid3DAction); // FadeOutTRTiles
	rb_cFadeOutBLTiles = rb_define_class_under(rb_mActions, "FadeOutBLTiles", rb_cFadeOutTRTiles); // FadeOutBLTiles
	rb_cFadeOutUpTiles = rb_define_class_under(rb_mActions, "FadeOutUpTiles", rb_cFadeOutTRTiles); // FadeOutUpTiles
	rb_cFadeOutDownTiles = rb_define_class_under(rb_mActions, "FadeOutDownTiles", rb_cFadeOutUpTiles); // FadeOutDownTiles
	rb_cTurnOffTiles = rb_define_class_under(rb_mActions, "TurnOffTiles", rb_cTiledGrid3DAction); // TurnOffTiles
	rb_cWavesTiles3D = rb_define_class_under(rb_mActions, "WavesTiles3D", rb_cTiledGrid3DAction); // WavesTiles3D
	rb_cJumpTiles3D = rb_define_class_under(rb_mActions, "JumpTiles3D", rb_cTiledGrid3DAction); // JumpTiles3D
	rb_cSplitRows = rb_define_class_under(rb_mActions, "SplitRows", rb_cTiledGrid3DAction); // SplitRows
	rb_cSplitCols = rb_define_class_under(rb_mActions, "SplitCols", rb_cTiledGrid3DAction); // SplitCols
	
	// +new+ methods for every subclass
	// generated by
	// cat cocos2d-iphone/cocos2d/*Action.h | grep @interface | ruby -ne 'md = $_.match(/@interface +(\w+) *: *(\w+)/); puts "\trb_define_singleton_method(rb_c#{md[1]}, \"new\", rb_c#{md[1]}_s_new, -1);" if md'
	rb_define_singleton_method(rb_cAction, "new", rb_cAction_s_new, -1);
	rb_define_singleton_method(rb_cFiniteTimeAction, "new", rb_cFiniteTimeAction_s_new, -1);
	rb_define_singleton_method(rb_cRepeatForever, "new", rb_cRepeatForever_s_new, -1);
	rb_define_singleton_method(rb_cSpeed, "new", rb_cSpeed_s_new, -1);
	rb_define_singleton_method(rb_cCameraAction, "new", rb_cCameraAction_s_new, -1);
	rb_define_singleton_method(rb_cOrbitCamera, "new", rb_cOrbitCamera_s_new, -1);
	rb_define_singleton_method(rb_cEaseAction, "new", rb_cEaseAction_s_new, -1);
	rb_define_singleton_method(rb_cEaseRateAction, "new", rb_cEaseRateAction_s_new, -1);
	rb_define_singleton_method(rb_cEaseIn, "new", rb_cEaseIn_s_new, -1);
	rb_define_singleton_method(rb_cEaseOut, "new", rb_cEaseOut_s_new, -1);
	rb_define_singleton_method(rb_cEaseInOut, "new", rb_cEaseInOut_s_new, -1);
	rb_define_singleton_method(rb_cEaseExponentialIn, "new", rb_cEaseExponentialIn_s_new, -1);
	rb_define_singleton_method(rb_cEaseExponentialOut, "new", rb_cEaseExponentialOut_s_new, -1);
	rb_define_singleton_method(rb_cEaseExponentialInOut, "new", rb_cEaseExponentialInOut_s_new, -1);
	rb_define_singleton_method(rb_cEaseSineIn, "new", rb_cEaseSineIn_s_new, -1);
	rb_define_singleton_method(rb_cEaseSineOut, "new", rb_cEaseSineOut_s_new, -1);
	rb_define_singleton_method(rb_cEaseSineInOut, "new", rb_cEaseSineInOut_s_new, -1);
	rb_define_singleton_method(rb_cWaves3D, "new", rb_cWaves3D_s_new, -1);
	rb_define_singleton_method(rb_cFlipX3D, "new", rb_cFlipX3D_s_new, -1);
	rb_define_singleton_method(rb_cFlipY3D, "new", rb_cFlipY3D_s_new, -1);
	rb_define_singleton_method(rb_cLens3D, "new", rb_cLens3D_s_new, -1);
	rb_define_singleton_method(rb_cRipple3D, "new", rb_cRipple3D_s_new, -1);
	rb_define_singleton_method(rb_cShaky3D, "new", rb_cShaky3D_s_new, -1);
	rb_define_singleton_method(rb_cLiquid, "new", rb_cLiquid_s_new, -1);
	rb_define_singleton_method(rb_cWaves, "new", rb_cWaves_s_new, -1);
	rb_define_singleton_method(rb_cTwirl, "new", rb_cTwirl_s_new, -1);
	rb_define_singleton_method(rb_cGridAction, "new", rb_cGridAction_s_new, -1);
	rb_define_singleton_method(rb_cGrid3DAction, "new", rb_cGrid3DAction_s_new, -1);
	rb_define_singleton_method(rb_cTiledGrid3DAction, "new", rb_cTiledGrid3DAction_s_new, -1);
	rb_define_singleton_method(rb_cAccelDeccelAmplitude, "new", rb_cAccelDeccelAmplitude_s_new, -1);
	rb_define_singleton_method(rb_cAccelAmplitude, "new", rb_cAccelAmplitude_s_new, -1);
	rb_define_singleton_method(rb_cDeccelAmplitude, "new", rb_cDeccelAmplitude_s_new, -1);
	rb_define_singleton_method(rb_cStopGrid, "new", rb_cStopGrid_s_new, -1);
	rb_define_singleton_method(rb_cReuseGrid, "new", rb_cReuseGrid_s_new, -1);
	rb_define_singleton_method(rb_cInstantAction, "new", rb_cInstantAction_s_new, -1);
	rb_define_singleton_method(rb_cShow, "new", rb_cShow_s_new, -1);
	rb_define_singleton_method(rb_cHide, "new", rb_cHide_s_new, -1);
	rb_define_singleton_method(rb_cToggleVisibility, "new", rb_cToggleVisibility_s_new, -1);
	rb_define_singleton_method(rb_cPlace, "new", rb_cPlace_s_new, -1);
	rb_define_singleton_method(rb_cCallFunc, "new", rb_cCallFunc_s_new, -1);
	rb_define_singleton_method(rb_cCallFuncN, "new", rb_cCallFuncN_s_new, -1);
	rb_define_singleton_method(rb_cCallFuncND, "new", rb_cCallFuncND_s_new, -1);
	rb_define_singleton_method(rb_cIntervalAction, "new", rb_cIntervalAction_s_new, -1);
	rb_define_singleton_method(rb_cSequence, "new", rb_cSequence_s_new, -1);
	rb_define_singleton_method(rb_cRepeat, "new", rb_cRepeat_s_new, -1);
	rb_define_singleton_method(rb_cSpawn, "new", rb_cSpawn_s_new, -1);
	rb_define_singleton_method(rb_cRotateTo, "new", rb_cRotateTo_s_new, -1);
	rb_define_singleton_method(rb_cRotateBy, "new", rb_cRotateBy_s_new, -1);
	rb_define_singleton_method(rb_cMoveTo, "new", rb_cMoveTo_s_new, -1);
	rb_define_singleton_method(rb_cMoveBy, "new", rb_cMoveBy_s_new, -1);
	rb_define_singleton_method(rb_cJumpBy, "new", rb_cJumpBy_s_new, -1);
	rb_define_singleton_method(rb_cJumpTo, "new", rb_cJumpTo_s_new, -1);
//	rb_define_singleton_method(rb_cBezierBy, "new", rb_cBezierBy_s_new, -1);
	rb_define_singleton_method(rb_cScaleTo, "new", rb_cScaleTo_s_new, -1);
	rb_define_singleton_method(rb_cScaleBy, "new", rb_cScaleBy_s_new, -1);
	rb_define_singleton_method(rb_cBlink, "new", rb_cBlink_s_new, -1);
	rb_define_singleton_method(rb_cFadeIn, "new", rb_cFadeIn_s_new, -1);
	rb_define_singleton_method(rb_cFadeOut, "new", rb_cFadeOut_s_new, -1);
	rb_define_singleton_method(rb_cFadeTo, "new", rb_cFadeTo_s_new, -1);
	rb_define_singleton_method(rb_cTintTo, "new", rb_cTintTo_s_new, -1);
	rb_define_singleton_method(rb_cTintBy, "new", rb_cTintBy_s_new, -1);
	rb_define_singleton_method(rb_cDelayTime, "new", rb_cDelayTime_s_new, -1);
	rb_define_singleton_method(rb_cReverseTime, "new", rb_cReverseTime_s_new, -1);
	rb_define_singleton_method(rb_cAnimate, "new", rb_cAnimate_s_new, -1);
	rb_define_singleton_method(rb_cShakyTiles3D, "new", rb_cShakyTiles3D_s_new, -1);
	rb_define_singleton_method(rb_cShatteredTiles3D, "new", rb_cShatteredTiles3D_s_new, -1);
	rb_define_singleton_method(rb_cShuffleTiles, "new", rb_cShuffleTiles_s_new, -1);
	rb_define_singleton_method(rb_cFadeOutTRTiles, "new", rb_cFadeOutTRTiles_s_new, -1);
	rb_define_singleton_method(rb_cFadeOutBLTiles, "new", rb_cFadeOutBLTiles_s_new, -1);
	rb_define_singleton_method(rb_cFadeOutUpTiles, "new", rb_cFadeOutUpTiles_s_new, -1);
	rb_define_singleton_method(rb_cFadeOutDownTiles, "new", rb_cFadeOutDownTiles_s_new, -1);
	rb_define_singleton_method(rb_cTurnOffTiles, "new", rb_cTurnOffTiles_s_new, -1);
	rb_define_singleton_method(rb_cWavesTiles3D, "new", rb_cWavesTiles3D_s_new, -1);
	rb_define_singleton_method(rb_cJumpTiles3D, "new", rb_cJumpTiles3D_s_new, -1);
	rb_define_singleton_method(rb_cSplitRows, "new", rb_cSplitRows_s_new, -1);
	rb_define_singleton_method(rb_cSplitCols, "new", rb_cSplitCols_s_new, -1);
	// special methods for each action
	// generated by... hand :-P

	rb_define_method(rb_cFiniteTimeAction, "duration", rb_cFiniteTimeAction_duration, 0);
	rb_define_method(rb_cFiniteTimeAction, "duration=", rb_cFiniteTimeAction_set_duration, 1);
	rb_define_method(rb_cFiniteTimeAction, "reverse", rb_cFiniteTimeAction_reverse, 0);
	
	rb_define_method(rb_cSpeed, "speed", rb_cSpeed_speed, 0);
	rb_define_method(rb_cSpeed, "speed=", rb_cSpeed_set_speed, 1);

	// replace the stop method on Action (to be able to call the stop handler in ruby)
	sc_method_swap([Action class], @selector(stop), @selector(rb_stop));
}
